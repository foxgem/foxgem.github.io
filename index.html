<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>老胡随手记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="老胡随手记">
<meta property="og:url" content="http://foxgem.github.io/index.html">
<meta property="og:site_name" content="老胡随手记">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="老胡随手记">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="老胡随手记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">老胡随手记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://foxgem.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2016/09/iots-killer-app-is-not-home-security" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/iots-killer-app-is-not-home-security/" class="article-date">
  <time datetime="2016-09-07T12:39:43.000Z" itemprop="datePublished">2016-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/iots-killer-app-is-not-home-security/">物联网的杀手级应用并非家庭安全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在题为“<a href="https://techcrunch.com/2016/08/31/iots-killer-app-is-home-security/" target="_blank" rel="external">物联网的杀手级应用是家庭安全</a>”一文在<a href="https://techcrunch.com" target="_blank" rel="external">TechCrunch</a>发布后不久，<a href="https://techcrunch.com/2016/09/03/iots-killer-app-is-not-home-security/" target="_blank" rel="external">它的反对者</a>也很快在同一站点发布了。</p>
<p>相比较起来，我更同意后者。正如后文作者所言：</p>
<blockquote>
<p>It is built on the assumption that one’s Wi-Fi will always work, their internet connection will always be up, power will always be on and every piece of software and firmware is stable and trustworthy.</p>
</blockquote>
<p>而在这整个链条上，任何一个环节都有出错的可能。这一点，在我做<a href="http://www.shifudao.com" target="_blank" rel="external">师傅到</a>的时候，深有体会。在刚开始的一段时间内，整天就在排查到底是那一块出问题导致设备数据无法正常上传。</p>
<p>当整个基础设施都不完善的时候，上层建筑要繁荣昌盛是不太可能的。回首看看互联网、移动互联网的发展历程，就能发现何其相似。</p>
<p>关于作者的其他评述，大家尽可直接跑去看原文，这里只列出一条让我感触尤深的话：</p>
<blockquote>
<p>… but as the years go on what we’re starting to see is IoT finding its footing in augmenting other systems rather than revolutionizing them. And in some ways, it’s getting quite good at that.</p>
</blockquote>
<p>情况确实如此，而且也应该如此。就拿我目前从事的工业物联网来说，它本身实质上还是服务于工厂的设备使用和管理，而这些在很多年前其实就已经有不少系统对其进行了支撑。只不过由于当年受技术所限，靠人力来收集设备运行数据。再往上走，基本上就已经脱离设备运行时的范畴，根本不依赖于所谓的物联网技术。如今，由于技术的成熟度增强，故可借助物联网技术手段对其当年人工部分进行升级改造，同时在衍生出其他的应用场景。</p>
<p>但说到底，都当属“增强”之列。说到革命，哪有那么容易！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/09/iots-killer-app-is-not-home-security/" data-id="cissxpjeq001md4qcb3vbv98b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/阅读/">阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016/09/hbase-schema" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/hbase-schema/" class="article-date">
  <time datetime="2016-09-05T03:06:23.000Z" itemprop="datePublished">2016-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/hbase-schema/">HBase模式设计指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于初涉HBase的开发者，<a href="https://www.mapr.com/blog/guidelines-hbase-schema-design" target="_blank" rel="external">这篇文章提供了一份简明扼要的建模指南</a>。其中的几个观点对于关系数据库出身的开发者尤其重要：</p>
<ol>
<li>关系数据库优先关注实体和实体之间的关系，然后才设计查询和索引；HBase恰恰相反，它是<strong>“Query-First”</strong>的模式设计，在设计模式之前，尽可能地先将所有查询识别出来。</li>
<li>上一条的目的是避免无谓的远程访问，将一起访问的数据存放在一起。</li>
<li>Normalization在HBase中不再是金科玉律</li>
</ol>
<p>文后分别针对典型的关系给出相应的范例：</p>
<ul>
<li>父子关系</li>
<li>多对多关系</li>
<li>通用数据，即字典数据</li>
<li>自关联关系</li>
<li>树和图</li>
<li>继承关系</li>
</ul>
<p>虽然是一篇2015年发表的文章，但放在今天依旧不过时，对于刚刚开始学习HBase的开发者有很好的借鉴意义。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/09/hbase-schema/" data-id="cissxpjew001qd4qcyhrghlwk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016/09/four-burners-theory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/four-burners-theory/" class="article-date">
  <time datetime="2016-09-04T03:02:56.000Z" itemprop="datePublished">2016-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/four-burners-theory/">四炉膛理论（Four-Burners Theory）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://jamesclear.com/four-burners-theory" target="_blank" rel="external">这篇讨论工作/生活平衡的文章</a>让我知道了“四炉膛理论”：</p>
<blockquote>
<p>Imagine that your life is represented by a stove with four burners on it. Each burner symbolizes one major quadrant of your life.</p>
<ol>
<li>The first burner represents your family.</li>
<li>The second burner is your friends.</li>
<li>The third burner is your health.</li>
<li>The fourth burner is your work.</li>
</ol>
<p>The Four Burners Theory says that “in order to be successful you have to cut off one of your burners. And in order to be really successful you have to cut off two.”</p>
</blockquote>
<p>讲白了，它的实质还是一再弹起的老调调：人的精力和时间是有限的，要想成功，就必须有重点地投入到你在意的那一个方面。按照这个理论，平衡工作和生活的结果就是平凡的人生。否则，若想走上人生巅峰，万人敬仰，那就得有所取舍。</p>
<p>关于烧炉子的技巧，作者在文后给出了3条建议，可供你参考：</p>
<ul>
<li>把炉膛外包出去，让你获得更多的时间和精力</li>
<li>承认现实，拥抱约束，想办法提高工作效率</li>
<li>规划人生，不同的阶段烧旺不同的炉膛</li>
</ul>
<p>最后一条建议挺有意思，不是吗？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/09/four-burners-theory/" data-id="cissxpjes001od4qcfeh9v0tw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/阅读/">阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016/07/design-thinking-for-job-learning" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/design-thinking-for-job-learning/" class="article-date">
  <time datetime="2016-07-28T01:38:29.000Z" itemprop="datePublished">2016-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/design-thinking-for-job-learning/">利用Design Thinking促进岗位培训</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>稍微正规点的公司基本都有岗位培训，至于效果，那就是“如人饮水，冷暖自知”了。就我来说的话，我是不太满意的。因为发现这实在是一个投入产出比太不对称的事情，不论培训时如何投入，待到培训结束后，时间稍微久一点，不少人就会忘掉大部分的培训内容。这不能怪其他人，因为这就是被动接收知识的效果。</p>
<p>在我发现这个问题之后，我也做过其他尝试，如变被动为主动，试着让参加培训的同事的参与感更强，更多的采用问答方式。最近，又尝试将社区活动中学到的“闪电演讲”方式引入课堂。即：在15分钟内讲完一个主题。这种方式的目的更多的是帮助大家开拓视野，发现各自的兴趣点。若感觉有意思，便在课后自行投入时间；反之，也就15分钟而已，就当见见世面。</p>
<p>如今，Design Thinking逐渐走红，就连岗位培训中都有人进行了尝试。<a href="https://hbr.org/2016/07/using-design-thinking-to-embed-learning-in-our-jobs" target="_blank" rel="external">这篇文章</a>里介绍了将其应用到岗位培训中的做法，甚觉有趣：</p>
<blockquote>
<p>Rather than inject “training” into employees, it studied the job of a retail sales agent over the first nine months and developed a “journey map” showing what people need to know the first day, the first week, the first month, and then over the first few quarters.</p>
</blockquote>
<p>这种方式最大的特点便是目的性极强，循序渐进地将一个员工所需掌握的知识以地图的形式表现出来。既指出了未来的终点，同时兼顾了眼前急需的技能，不至于一开始就抛出大量的内容让新人觉得负担过重。话说哥最近整理的公司技术部的“技能图谱”也与此方式相互呼应，要是能跟级别在挂上钩就更完美了。</p>
<p>除了整理出“journey map”，这家公司还为培训制作了专门的APP：</p>
<blockquote>
<p>Rather than try to cram all this into a set of formal or informal learning programs, the company built an app, which looks more like a game than a learning system. It is designed to give people the basic information they need before they even come to work, then later add social connections, coaching sessions, and videos that help them on the job, and even encourage them to share what they’ve learned online.</p>
</blockquote>
<p>正如文章中指出的：这种由“教学设计”到“体验设计”的转变非常重要，因为：</p>
<blockquote>
<p>In today’s always-on, distracting work environment, people simply don’t take the time to learn unless it feels relevant and it’s embedded in the work.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/07/design-thinking-for-job-learning/" data-id="cissxpjeo001kd4qcpzbbzx8v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/阅读/">阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016/07/vertx-circuit-breaker-example" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/vertx-circuit-breaker-example/" class="article-date">
  <time datetime="2016-07-11T09:30:03.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/vertx-circuit-breaker-example/">Vert.x Circuit Breaker须知</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Vert.x 3.3新增的<a href="http://vertx.io/docs/vertx-circuit-breaker/java/" target="_blank" rel="external">Circuit Breaker</a>深得我心，使用简单，而且文档齐全。今天照着文档写了<a href="https://github.com/shifudao/how-to/tree/master/circuitbreaker" target="_blank" rel="external">一个探索性的例子</a>，为接下来的项目做技术性预研。</p>
<p>整个过程非常顺利，但有几点有必要说明一下：</p>
<ul>
<li>future.complete()必须被调用，无论有无返回值，否则这次执行不会被认为是结束，进而导致超时。</li>
<li>为了让CircuitBreaker检查到超时，在CircuitBreaker.execute()外部套了一层vertx.executeBlocking()，否则即便CircuitBreaker.execute()内的操作的执行时间超过了外部设置的时间长度，CircuitBreaker也不会检查到。</li>
</ul>
<p>总得来说，还是不错。只不过需要注意该版本还只是技术预览版，不排除以后有接口变动的可能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/07/vertx-circuit-breaker-example/" data-id="cissxpjem001hd4qcebz39xes" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016/07/vertx-tcp-eventbus-bridge" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/vertx-tcp-eventbus-bridge/" class="article-date">
  <time datetime="2016-07-05T12:27:19.000Z" itemprop="datePublished">2016-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/vertx-tcp-eventbus-bridge/">Vert.x TCP EventBus Bridge补遗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如果没有记错的话，Vert.x从3.2就开始支持<a href="http://vertx.io/docs/vertx-tcp-eventbus-bridge/java/" target="_blank" rel="external">TCP Eventbus Bridge</a>了，它使得Client可以直接通过socket跟Vert.x EventBus进行通信。可遗憾的是，整个文档就像半成品，并没有把很多事情说清楚。</p>
<p>为了搞清楚这个特性，今天抽空完成了一个TCP Eventbus Bridge的例子，源码见<a href="https://github.com/shifudao/how-to/tree/master/vertx-tcp-eventbridge" target="_blank" rel="external">这里</a>。</p>
<p>按理，都已经用TCP了，Client和Server之间干嘛还需要多此一举地采用所谓的Eventbus Bridge？我认为：</p>
<ul>
<li>Server和Client之间采用这种方式进行通信可以让Server端的代码更加清晰明了</li>
<li>Client和Server之间的交互模式也更简单一些：<ul>
<li>对于request-response，server简单地message.reply即可</li>
<li>对于某些广播消息，client向多个server实例广播，或者是server向多个client广播，又或某些client也想接收另外的client向server的广播都非常简单和直观。</li>
<li>通过注册地址，client也可以收到感兴趣的消息，不论是server发的，还是client发的</li>
</ul>
</li>
</ul>
<p>这两点可参考例子源码详细了解。整个例子很简单，实现了：</p>
<ul>
<li>client向多个bridge send，则只有一个bridge可以收到</li>
<li>client向多个bridge publish，则都能收到</li>
<li>server和client之间的request-response</li>
<li>client注册要接受某地址的消息</li>
</ul>
<p>关于API的使用，有以下几点需要注意：</p>
<ul>
<li>bridge在server端建立，client只需要使用普通socket去连接即可</li>
<li>client要接收某地址的消息，仍然是使用socket来接收。因为client并不一定是Vert.x应用，并没有eventbus可用！这一点是引起我误解，同时文档没有讲清楚的地方。</li>
<li>对于Java语言，使用io.vertx.ext.eventbus.bridge.tcp.impl.protocol.FrameHelper和io.vertx.ext.eventbus.bridge.tcp.impl.protocol.FrameParser可以简化数据帧的发送和解析。可遗憾的是，没有提供其他语言，如Groovy的对应工具类，弄得我只好采用一种变通的方式去用【还是看代码去了解】。因此，对于Vert.x开发，建议还是首选Java语言来做，可以省掉一些不必要的麻烦。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/07/vertx-tcp-eventbus-bridge/" data-id="cissxpjf0001sd4qcc18c5u0m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016/07/being-data-scientist" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/being-data-scientist/" class="article-date">
  <time datetime="2016-07-03T11:44:06.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/being-data-scientist/">数据科学家养成之道</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本来想等到这个由三篇文章组成的系列完结才写这篇笔记，无奈最后一篇迟迟不见更新，且看完标题之后，个人觉得前两篇内容足以涵盖“数据科学家养成”这一主题，故手指一抖，本笔记就诞生了。</p>
<p>闲话少说，书归正传。这个主题为“How to Become a Data Scientist”的系列博文按作者的规划共计三篇，分别是：<a href="https://www.experfy.com/blog/how-to-become-a-data-scientist-part-1-3" target="_blank" rel="external">数据科学家是何方神圣</a>、<a href="https://www.experfy.com/blog/how-to-become-a-data-scientist-part-2-3" target="_blank" rel="external">修炼之路</a>和就业前景。目前就剩最后一篇未公开，但窃以为主要也就是说明一下该职业的广阔就业前景，以及是目前最炙手可热的高逼格职业等等。就如何成功挤入这一未来热门职业来说，单看标题便知道前两篇已经是重点了。</p>
<p>想成数据科学家，就得先了解他们要求的技能，文中列出的清单可谓比较详尽了：</p>
<ul>
<li>解决问题的能力</li>
<li>统计/机器学习</li>
<li>计算机相关技能<ul>
<li>编程</li>
<li>分布式计算</li>
<li>软件工程</li>
</ul>
</li>
<li>数据整理（data wrangling）</li>
<li>相关工具和技术</li>
<li>沟通/业务敏感度</li>
</ul>
<p>其中作者提到最关键的能力是第一条，我深以为然，若不是一个问题解决者，难以成为优秀的数据科学家，只能是书呆子。鉴于这令人生畏的清单，作者向每位有志成为数据科学家的人提出了三个问题</p>
<blockquote>
<ol>
<li>Why do you want to be a data scientist?</li>
<li>What type of data science interests you?</li>
<li>What natural capabilities or relevant skills do you already possess?</li>
</ol>
</blockquote>
<p>为何要问这三个问题？作者意图：</p>
<blockquote>
<p>you need to have the right reasons for going down this path, otherwise – chances are – you will give up when the going gets tough (and it will).</p>
</blockquote>
<p>在后续的内容中，作者引述了一系列过来人的经验之谈，看看还是有帮助的。会有助于你想清楚了再投入到这个职业中来，而不是因为看到目前这个职业吃香，脑子一热就发下宏愿再苦再累也要上，结果稍遇困难就临阵退缩。</p>
<p>作为一篇合格的养成指南，指出技能要求之后当然是要指出修炼之路，这里也不例外。基本上就是列出各种资料，学习方法，以及探讨是否值得去读PhD（鉴于其所需技能的理论性比较高）。在第二篇最有收获的就是知道了<a href="https://www.kaggle.com" target="_blank" rel="external">Kaggle</a>（请原谅我的孤陋寡闻，没听说的请自觉Google）</p>
<p>诚如作者一再强调，成为数据科学家的方法就是实践、实践、再实践。除此之外别无捷径，所以，骚年们，加油吧！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/07/being-data-scientist/" data-id="cissxpjef001fd4qcpi0xo01x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据科学/">数据科学</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016/06/es-as-tsdb" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/es-as-tsdb/" class="article-date">
  <time datetime="2016-06-30T08:06:28.000Z" itemprop="datePublished">2016-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/es-as-tsdb/">作为TSDB的Elasticsearch</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Elasticsearch可作为TSDB已经早有耳闻，而且自从v2版本之后，更是加了很多特性，使其更加适合作为TSDB使用。而<a href="https://www.elastic.co/blog/elasticsearch-as-a-time-series-data-store" target="_blank" rel="external">这一篇文章</a>给出了一个详细的例子，个人认为其最有价值的地方在于给出了一个参考的<a href="https://github.com/stagemonitor/stagemonitor/blob/influxdb/stagemonitor-core/src/main/resources/stagemonitor-elasticsearch-metrics-index-template.json" target="_blank" rel="external">schema mapping</a>。尤其是其中将”_all”和”_source”设为关闭，余心有戚戚焉。</p>
<p>同时，对于长期存储的优化建议也不错，但终究赶不上上面提到的mapping更直接，:)</p>
<p>附带说一句，文中提到的<a href="http://www.stagemonitor.org/" target="_blank" rel="external">stagemonitor</a>很让人惊艳，打算抽时间看看。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/06/es-as-tsdb/" data-id="cissxpjd40009d4qcbo6on2of" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016/06/speed-up-pagination" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/speed-up-pagination/" class="article-date">
  <time datetime="2016-06-13T11:41:15.000Z" itemprop="datePublished">2016-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/speed-up-pagination/">采用Seek Method加速分页</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是今天在<a href="http://use-the-index-luke.com/no-offset" target="_blank" rel="external">码天狗周刊上看到的文章</a>，加上之前曾有过切身体会（只不过不是在SQL上），故觉得有必要摘记下来广而告之。</p>
<p>凡事做过页面的，一般对分页不会陌生，也不会觉得它有多难：就是limit + offset的组合就可以了呀。但是，危险往往都是从最不起眼的地方开始的。在这里，我先说一下我之前在用MongoDB时遇到的问题。这类问题同样会出现在这种分页方式上。</p>
<p>当时，我需要对于MongoDB中的数据进行处理，每次处理一批，也相当于是按页来操作数据啦。这个没啥难度，直接使用API中的find + skip + limit就可以轻易搞定。迅速把程序写完之后就开始拿产品库开搞了。刚开始一切正常，可过了没多久，就发现整个程序的性能下降了。进入Mongo一查，发现是Table Scan。哇，那个collection中有上千万的数据啊！</p>
<p>此处略去3000字。</p>
<p>总之，问题最后解决了，程序又运行如飞。而解决之道很简单：只用find + limit，不再使用skip（原因自己想）。只不过在find中加了一个条件：上一批的最后一个document的_id。整个代码形似（groovy代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (docId) &#123;</span><br><span class="line">    batch = collection.find([&apos;_id&apos;: [&apos;$gt&apos;: docId]] as Document).limit(BATCH_SIZE)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    batch = collection.find().limit(BATCH_SIZE)</span><br><span class="line">&#125;</span><br><span class="line">docId = batch[-1][&apos;_id&apos;]</span><br></pre></td></tr></table></figure>
<p>它的原理很简单，其实就是利用可以利用的index来加速分页。这种思想跟今天看到的文章的思路如出一辙，不再使用offset，寻找能达到同样效果的index，用它来助力搜索。因此，文中给出的方案跟上面的代码类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT ...</span><br><span class="line">  FROM ...</span><br><span class="line"> WHERE ...</span><br><span class="line">   AND id &lt; ?last_seen_id</span><br><span class="line"> ORDER BY id DESC</span><br><span class="line"> FETCH FIRST 10 ROWS ONLY</span><br></pre></td></tr></table></figure>
<p>这种分页方式被称为“seek method”，其中的id被称为“seek predicate”。典型的seek predicate还可以是日期。需要提醒的是，seek predicate上需要有index才有意义，而且它可以有多列！采用这种方式的分页可以避免上述分页的潜在危险：当页数达到一定量之后，分页速度会严重下降。</p>
<p>关于seek method，还可以参考下面的文章：</p>
<ul>
<li><a href="https://blog.jooq.org/2013/10/26/faster-sql-paging-with-jooq-using-the-seek-method/" target="_blank" rel="external">https://blog.jooq.org/2013/10/26/faster-sql-paging-with-jooq-using-the-seek-method/</a></li>
<li><a href="http://use-the-index-luke.com/sql/partial-results/fetch-next-page" target="_blank" rel="external">http://use-the-index-luke.com/sql/partial-results/fetch-next-page</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/06/speed-up-pagination/" data-id="cissxpjdo000md4qcu7bvru7s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2016/06/interesting-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/interesting-3/" class="article-date">
  <time datetime="2016-06-12T11:06:01.000Z" itemprop="datePublished">2016-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/interesting-3/">趣文三则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天阅读了三篇有趣的短文，因为都不长而且易懂，所以就一起记下了。</p>
<h2 id="漫画：is-Java-Dying？"><a href="#漫画：is-Java-Dying？" class="headerlink" title="漫画：is Java Dying？"></a><a href="https://dzone.com/articles/big-numbers-comic" target="_blank" rel="external">漫画：is Java Dying？</a></h2><p>知道天堂排名第三的人造数字是什么？咳咳，那就是“宣传Java正走向死亡的文章数量”，:)</p>
<h2 id="消灭if语句的方法总结"><a href="#消灭if语句的方法总结" class="headerlink" title="消灭if语句的方法总结"></a><a href="http://code.joejag.com/2016/anti-if-the-missing-patterns.html" target="_blank" rel="external">消灭if语句的方法总结</a></h2><p>if语句的问题已经是路人皆知了，文章介绍了5种方法来消灭它：</p>
<ul>
<li>若方法的参数中有布尔类型，那就写成两个方法，一个对应false，另一个对应true</li>
<li>用多态来替换switch语句</li>
<li>采用Optional或NullObject避免null判断<ul>
<li>Optional在Java 8或Guava中都有</li>
<li>NullObject，典型的如空数组或空字符串，视使用情况而定。Optional本质上也是一种NullObject。</li>
</ul>
</li>
<li>尽量用inline语句来表达，如布尔表达式或三目运算符</li>
<li>将反复出现的if语句往调用链的上游移动</li>
</ul>
<p>个人认为，可以从公共方法，且调用方最常用的那部分开始，逐步向内推进，这样可以让外层逻辑清爽很多。</p>
<h2 id="谎言的4种语言特征"><a href="#谎言的4种语言特征" class="headerlink" title="谎言的4种语言特征"></a><a href="http://lifehacker.com/learn-to-spot-a-liar-with-these-verbal-signs-1780047717" target="_blank" rel="external">谎言的4种语言特征</a></h2><p>这篇文章相当于文中内嵌Ted视频的文字解读，列出了谎言的四种语言特征：</p>
<ul>
<li>尽可能少的自我引用，一般采用第三人称说话</li>
<li>负面的语言，由于负罪感作祟</li>
<li>简单阐述，因为大脑很难产生复杂的谎言</li>
<li>故意用冗长晦涩的表达方式来讲一件简单的事情，简而言之就是“绕着弯说话”</li>
</ul>
<p>今天的阅读小结就到这里，谢谢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://foxgem.github.io/2016/06/interesting-3/" data-id="cissxpjcv0004d4qc44i1uo45" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/阅读/">阅读</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/The-Morning-Paper/">The Morning Paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全/">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发/">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据科学/">数据科学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/The-Morning-Paper/" style="font-size: 14px;">The Morning Paper</a> <a href="/tags/安全/" style="font-size: 12px;">安全</a> <a href="/tags/开发/" style="font-size: 18px;">开发</a> <a href="/tags/微服务/" style="font-size: 12px;">微服务</a> <a href="/tags/数据库/" style="font-size: 16px;">数据库</a> <a href="/tags/数据科学/" style="font-size: 10px;">数据科学</a> <a href="/tags/阅读/" style="font-size: 20px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/iots-killer-app-is-not-home-security/">物联网的杀手级应用并非家庭安全</a>
          </li>
        
          <li>
            <a href="/2016/09/hbase-schema/">HBase模式设计指南</a>
          </li>
        
          <li>
            <a href="/2016/09/four-burners-theory/">四炉膛理论（Four-Burners Theory）</a>
          </li>
        
          <li>
            <a href="/2016/07/design-thinking-for-job-learning/">利用Design Thinking促进岗位培训</a>
          </li>
        
          <li>
            <a href="/2016/07/vertx-circuit-breaker-example/">Vert.x Circuit Breaker须知</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 胡键（jianhgreat@hotmail.com）<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
<!-- Baidu Tongji -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?1f898523fbfe8b3547cd3812290e6f84";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- End Baidu Tongji -->

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//code.jquery.com/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>