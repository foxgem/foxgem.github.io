<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老胡随手记</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://foxgem.github.io/"/>
  <updated>2016-09-07T13:21:49.000Z</updated>
  <id>http://foxgem.github.io/</id>
  
  <author>
    <name>胡键（jianhgreat@hotmail.com）</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>物联网的杀手级应用并非家庭安全</title>
    <link href="http://foxgem.github.io/2016/09/iots-killer-app-is-not-home-security/"/>
    <id>http://foxgem.github.io/2016/09/iots-killer-app-is-not-home-security/</id>
    <published>2016-09-07T12:39:43.000Z</published>
    <updated>2016-09-07T13:21:49.000Z</updated>
    
    <content type="html">&lt;p&gt;在题为“&lt;a href=&quot;https://techcrunch.com/2016/08/31/iots-killer-app-is-home-security/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;物联网的杀手级应用是家庭安全&lt;/a&gt;”一文在&lt;a href=&quot;https://techcrunch.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TechCrunch&lt;/a&gt;发布后不久，&lt;a href=&quot;https://techcrunch.com/2016/09/03/iots-killer-app-is-not-home-security/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;它的反对者&lt;/a&gt;也很快在同一站点发布了。&lt;/p&gt;
&lt;p&gt;相比较起来，我更同意后者。正如后文作者所言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is built on the assumption that one’s Wi-Fi will always work, their internet connection will always be up, power will always be on and every piece of software and firmware is stable and trustworthy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而在这整个链条上，任何一个环节都有出错的可能。这一点，在我做&lt;a href=&quot;http://www.shifudao.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;师傅到&lt;/a&gt;的时候，深有体会。在刚开始的一段时间内，整天就在排查到底是那一块出问题导致设备数据无法正常上传。&lt;/p&gt;
&lt;p&gt;当整个基础设施都不完善的时候，上层建筑要繁荣昌盛是不太可能的。回首看看互联网、移动互联网的发展历程，就能发现何其相似。&lt;/p&gt;
&lt;p&gt;关于作者的其他评述，大家尽可直接跑去看原文，这里只列出一条让我感触尤深的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;… but as the years go on what we’re starting to see is IoT finding its footing in augmenting other systems rather than revolutionizing them. And in some ways, it’s getting quite good at that.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;情况确实如此，而且也应该如此。就拿我目前从事的工业物联网来说，它本身实质上还是服务于工厂的设备使用和管理，而这些在很多年前其实就已经有不少系统对其进行了支撑。只不过由于当年受技术所限，靠人力来收集设备运行数据。再往上走，基本上就已经脱离设备运行时的范畴，根本不依赖于所谓的物联网技术。如今，由于技术的成熟度增强，故可借助物联网技术手段对其当年人工部分进行升级改造，同时在衍生出其他的应用场景。&lt;/p&gt;
&lt;p&gt;但说到底，都当属“增强”之列。说到革命，哪有那么容易！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在题为“&lt;a href=&quot;https://techcrunch.com/2016/08/31/iots-killer-app-is-home-security/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;物联网的杀手级应用是家庭安全&lt;/a&gt;”一文在&lt;a
    
    </summary>
    
    
      <category term="阅读" scheme="http://foxgem.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>HBase模式设计指南</title>
    <link href="http://foxgem.github.io/2016/09/hbase-schema/"/>
    <id>http://foxgem.github.io/2016/09/hbase-schema/</id>
    <published>2016-09-05T03:06:23.000Z</published>
    <updated>2016-09-05T03:23:57.000Z</updated>
    
    <content type="html">&lt;p&gt;对于初涉HBase的开发者，&lt;a href=&quot;https://www.mapr.com/blog/guidelines-hbase-schema-design&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章提供了一份简明扼要的建模指南&lt;/a&gt;。其中的几个观点对于关系数据库出身的开发者尤其重要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关系数据库优先关注实体和实体之间的关系，然后才设计查询和索引；HBase恰恰相反，它是&lt;strong&gt;“Query-First”&lt;/strong&gt;的模式设计，在设计模式之前，尽可能地先将所有查询识别出来。&lt;/li&gt;
&lt;li&gt;上一条的目的是避免无谓的远程访问，将一起访问的数据存放在一起。&lt;/li&gt;
&lt;li&gt;Normalization在HBase中不再是金科玉律&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;文后分别针对典型的关系给出相应的范例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父子关系&lt;/li&gt;
&lt;li&gt;多对多关系&lt;/li&gt;
&lt;li&gt;通用数据，即字典数据&lt;/li&gt;
&lt;li&gt;自关联关系&lt;/li&gt;
&lt;li&gt;树和图&lt;/li&gt;
&lt;li&gt;继承关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然是一篇2015年发表的文章，但放在今天依旧不过时，对于刚刚开始学习HBase的开发者有很好的借鉴意义。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对于初涉HBase的开发者，&lt;a href=&quot;https://www.mapr.com/blog/guidelines-hbase-schema-design&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章提供了一份简明扼要的建模指南&lt;/a&gt;。其中
    
    </summary>
    
    
      <category term="数据库" scheme="http://foxgem.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>四炉膛理论（Four-Burners Theory）</title>
    <link href="http://foxgem.github.io/2016/09/four-burners-theory/"/>
    <id>http://foxgem.github.io/2016/09/four-burners-theory/</id>
    <published>2016-09-04T03:02:56.000Z</published>
    <updated>2016-09-04T03:54:36.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://jamesclear.com/four-burners-theory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇讨论工作/生活平衡的文章&lt;/a&gt;让我知道了“四炉膛理论”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Imagine that your life is represented by a stove with four burners on it. Each burner symbolizes one major quadrant of your life.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first burner represents your family.&lt;/li&gt;
&lt;li&gt;The second burner is your friends.&lt;/li&gt;
&lt;li&gt;The third burner is your health.&lt;/li&gt;
&lt;li&gt;The fourth burner is your work.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The Four Burners Theory says that “in order to be successful you have to cut off one of your burners. And in order to be really successful you have to cut off two.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讲白了，它的实质还是一再弹起的老调调：人的精力和时间是有限的，要想成功，就必须有重点地投入到你在意的那一个方面。按照这个理论，平衡工作和生活的结果就是平凡的人生。否则，若想走上人生巅峰，万人敬仰，那就得有所取舍。&lt;/p&gt;
&lt;p&gt;关于烧炉子的技巧，作者在文后给出了3条建议，可供你参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把炉膛外包出去，让你获得更多的时间和精力&lt;/li&gt;
&lt;li&gt;承认现实，拥抱约束，想办法提高工作效率&lt;/li&gt;
&lt;li&gt;规划人生，不同的阶段烧旺不同的炉膛&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后一条建议挺有意思，不是吗？&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://jamesclear.com/four-burners-theory&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇讨论工作/生活平衡的文章&lt;/a&gt;让我知道了“四炉膛理论”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Im
    
    </summary>
    
    
      <category term="阅读" scheme="http://foxgem.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>利用Design Thinking促进岗位培训</title>
    <link href="http://foxgem.github.io/2016/07/design-thinking-for-job-learning/"/>
    <id>http://foxgem.github.io/2016/07/design-thinking-for-job-learning/</id>
    <published>2016-07-28T01:38:29.000Z</published>
    <updated>2016-07-28T02:23:31.000Z</updated>
    
    <content type="html">&lt;p&gt;稍微正规点的公司基本都有岗位培训，至于效果，那就是“如人饮水，冷暖自知”了。就我来说的话，我是不太满意的。因为发现这实在是一个投入产出比太不对称的事情，不论培训时如何投入，待到培训结束后，时间稍微久一点，不少人就会忘掉大部分的培训内容。这不能怪其他人，因为这就是被动接收知识的效果。&lt;/p&gt;
&lt;p&gt;在我发现这个问题之后，我也做过其他尝试，如变被动为主动，试着让参加培训的同事的参与感更强，更多的采用问答方式。最近，又尝试将社区活动中学到的“闪电演讲”方式引入课堂。即：在15分钟内讲完一个主题。这种方式的目的更多的是帮助大家开拓视野，发现各自的兴趣点。若感觉有意思，便在课后自行投入时间；反之，也就15分钟而已，就当见见世面。&lt;/p&gt;
&lt;p&gt;如今，Design Thinking逐渐走红，就连岗位培训中都有人进行了尝试。&lt;a href=&quot;https://hbr.org/2016/07/using-design-thinking-to-embed-learning-in-our-jobs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;里介绍了将其应用到岗位培训中的做法，甚觉有趣：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rather than inject “training” into employees, it studied the job of a retail sales agent over the first nine months and developed a “journey map” showing what people need to know the first day, the first week, the first month, and then over the first few quarters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种方式最大的特点便是目的性极强，循序渐进地将一个员工所需掌握的知识以地图的形式表现出来。既指出了未来的终点，同时兼顾了眼前急需的技能，不至于一开始就抛出大量的内容让新人觉得负担过重。话说哥最近整理的公司技术部的“技能图谱”也与此方式相互呼应，要是能跟级别在挂上钩就更完美了。&lt;/p&gt;
&lt;p&gt;除了整理出“journey map”，这家公司还为培训制作了专门的APP：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rather than try to cram all this into a set of formal or informal learning programs, the company built an app, which looks more like a game than a learning system. It is designed to give people the basic information they need before they even come to work, then later add social connections, coaching sessions, and videos that help them on the job, and even encourage them to share what they’ve learned online.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如文章中指出的：这种由“教学设计”到“体验设计”的转变非常重要，因为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In today’s always-on, distracting work environment, people simply don’t take the time to learn unless it feels relevant and it’s embedded in the work.&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;稍微正规点的公司基本都有岗位培训，至于效果，那就是“如人饮水，冷暖自知”了。就我来说的话，我是不太满意的。因为发现这实在是一个投入产出比太不对称的事情，不论培训时如何投入，待到培训结束后，时间稍微久一点，不少人就会忘掉大部分的培训内容。这不能怪其他人，因为这就是被动接收知识
    
    </summary>
    
    
      <category term="阅读" scheme="http://foxgem.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Vert.x Circuit Breaker须知</title>
    <link href="http://foxgem.github.io/2016/07/vertx-circuit-breaker-example/"/>
    <id>http://foxgem.github.io/2016/07/vertx-circuit-breaker-example/</id>
    <published>2016-07-11T09:30:03.000Z</published>
    <updated>2016-07-11T10:00:06.000Z</updated>
    
    <content type="html">&lt;p&gt;Vert.x 3.3新增的&lt;a href=&quot;http://vertx.io/docs/vertx-circuit-breaker/java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Circuit Breaker&lt;/a&gt;深得我心，使用简单，而且文档齐全。今天照着文档写了&lt;a href=&quot;https://github.com/shifudao/how-to/tree/master/circuitbreaker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一个探索性的例子&lt;/a&gt;，为接下来的项目做技术性预研。&lt;/p&gt;
&lt;p&gt;整个过程非常顺利，但有几点有必要说明一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;future.complete()必须被调用，无论有无返回值，否则这次执行不会被认为是结束，进而导致超时。&lt;/li&gt;
&lt;li&gt;为了让CircuitBreaker检查到超时，在CircuitBreaker.execute()外部套了一层vertx.executeBlocking()，否则即便CircuitBreaker.execute()内的操作的执行时间超过了外部设置的时间长度，CircuitBreaker也不会检查到。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总得来说，还是不错。只不过需要注意该版本还只是技术预览版，不排除以后有接口变动的可能。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Vert.x 3.3新增的&lt;a href=&quot;http://vertx.io/docs/vertx-circuit-breaker/java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Circuit Breaker&lt;/a&gt;深得我心，使用简单，而且文档齐
    
    </summary>
    
    
      <category term="开发" scheme="http://foxgem.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Vert.x TCP EventBus Bridge补遗</title>
    <link href="http://foxgem.github.io/2016/07/vertx-tcp-eventbus-bridge/"/>
    <id>http://foxgem.github.io/2016/07/vertx-tcp-eventbus-bridge/</id>
    <published>2016-07-05T12:27:19.000Z</published>
    <updated>2016-07-05T13:08:25.000Z</updated>
    
    <content type="html">&lt;p&gt;如果没有记错的话，Vert.x从3.2就开始支持&lt;a href=&quot;http://vertx.io/docs/vertx-tcp-eventbus-bridge/java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TCP Eventbus Bridge&lt;/a&gt;了，它使得Client可以直接通过socket跟Vert.x EventBus进行通信。可遗憾的是，整个文档就像半成品，并没有把很多事情说清楚。&lt;/p&gt;
&lt;p&gt;为了搞清楚这个特性，今天抽空完成了一个TCP Eventbus Bridge的例子，源码见&lt;a href=&quot;https://github.com/shifudao/how-to/tree/master/vertx-tcp-eventbridge&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;按理，都已经用TCP了，Client和Server之间干嘛还需要多此一举地采用所谓的Eventbus Bridge？我认为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server和Client之间采用这种方式进行通信可以让Server端的代码更加清晰明了&lt;/li&gt;
&lt;li&gt;Client和Server之间的交互模式也更简单一些：&lt;ul&gt;
&lt;li&gt;对于request-response，server简单地message.reply即可&lt;/li&gt;
&lt;li&gt;对于某些广播消息，client向多个server实例广播，或者是server向多个client广播，又或某些client也想接收另外的client向server的广播都非常简单和直观。&lt;/li&gt;
&lt;li&gt;通过注册地址，client也可以收到感兴趣的消息，不论是server发的，还是client发的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两点可参考例子源码详细了解。整个例子很简单，实现了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;client向多个bridge send，则只有一个bridge可以收到&lt;/li&gt;
&lt;li&gt;client向多个bridge publish，则都能收到&lt;/li&gt;
&lt;li&gt;server和client之间的request-response&lt;/li&gt;
&lt;li&gt;client注册要接受某地址的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于API的使用，有以下几点需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bridge在server端建立，client只需要使用普通socket去连接即可&lt;/li&gt;
&lt;li&gt;client要接收某地址的消息，仍然是使用socket来接收。因为client并不一定是Vert.x应用，并没有eventbus可用！这一点是引起我误解，同时文档没有讲清楚的地方。&lt;/li&gt;
&lt;li&gt;对于Java语言，使用io.vertx.ext.eventbus.bridge.tcp.impl.protocol.FrameHelper和io.vertx.ext.eventbus.bridge.tcp.impl.protocol.FrameParser可以简化数据帧的发送和解析。可遗憾的是，没有提供其他语言，如Groovy的对应工具类，弄得我只好采用一种变通的方式去用【还是看代码去了解】。因此，对于Vert.x开发，建议还是首选Java语言来做，可以省掉一些不必要的麻烦。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如果没有记错的话，Vert.x从3.2就开始支持&lt;a href=&quot;http://vertx.io/docs/vertx-tcp-eventbus-bridge/java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TCP Eventbus Bridge
    
    </summary>
    
    
      <category term="开发" scheme="http://foxgem.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>数据科学家养成之道</title>
    <link href="http://foxgem.github.io/2016/07/being-data-scientist/"/>
    <id>http://foxgem.github.io/2016/07/being-data-scientist/</id>
    <published>2016-07-03T11:44:06.000Z</published>
    <updated>2016-07-03T12:18:25.000Z</updated>
    
    <content type="html">&lt;p&gt;本来想等到这个由三篇文章组成的系列完结才写这篇笔记，无奈最后一篇迟迟不见更新，且看完标题之后，个人觉得前两篇内容足以涵盖“数据科学家养成”这一主题，故手指一抖，本笔记就诞生了。&lt;/p&gt;
&lt;p&gt;闲话少说，书归正传。这个主题为“How to Become a Data Scientist”的系列博文按作者的规划共计三篇，分别是：&lt;a href=&quot;https://www.experfy.com/blog/how-to-become-a-data-scientist-part-1-3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数据科学家是何方神圣&lt;/a&gt;、&lt;a href=&quot;https://www.experfy.com/blog/how-to-become-a-data-scientist-part-2-3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;修炼之路&lt;/a&gt;和就业前景。目前就剩最后一篇未公开，但窃以为主要也就是说明一下该职业的广阔就业前景，以及是目前最炙手可热的高逼格职业等等。就如何成功挤入这一未来热门职业来说，单看标题便知道前两篇已经是重点了。&lt;/p&gt;
&lt;p&gt;想成数据科学家，就得先了解他们要求的技能，文中列出的清单可谓比较详尽了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决问题的能力&lt;/li&gt;
&lt;li&gt;统计/机器学习&lt;/li&gt;
&lt;li&gt;计算机相关技能&lt;ul&gt;
&lt;li&gt;编程&lt;/li&gt;
&lt;li&gt;分布式计算&lt;/li&gt;
&lt;li&gt;软件工程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据整理（data wrangling）&lt;/li&gt;
&lt;li&gt;相关工具和技术&lt;/li&gt;
&lt;li&gt;沟通/业务敏感度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中作者提到最关键的能力是第一条，我深以为然，若不是一个问题解决者，难以成为优秀的数据科学家，只能是书呆子。鉴于这令人生畏的清单，作者向每位有志成为数据科学家的人提出了三个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Why do you want to be a data scientist?&lt;/li&gt;
&lt;li&gt;What type of data science interests you?&lt;/li&gt;
&lt;li&gt;What natural capabilities or relevant skills do you already possess?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;为何要问这三个问题？作者意图：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;you need to have the right reasons for going down this path, otherwise – chances are – you will give up when the going gets tough (and it will).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在后续的内容中，作者引述了一系列过来人的经验之谈，看看还是有帮助的。会有助于你想清楚了再投入到这个职业中来，而不是因为看到目前这个职业吃香，脑子一热就发下宏愿再苦再累也要上，结果稍遇困难就临阵退缩。&lt;/p&gt;
&lt;p&gt;作为一篇合格的养成指南，指出技能要求之后当然是要指出修炼之路，这里也不例外。基本上就是列出各种资料，学习方法，以及探讨是否值得去读PhD（鉴于其所需技能的理论性比较高）。在第二篇最有收获的就是知道了&lt;a href=&quot;https://www.kaggle.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kaggle&lt;/a&gt;（请原谅我的孤陋寡闻，没听说的请自觉Google）&lt;/p&gt;
&lt;p&gt;诚如作者一再强调，成为数据科学家的方法就是实践、实践、再实践。除此之外别无捷径，所以，骚年们，加油吧！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本来想等到这个由三篇文章组成的系列完结才写这篇笔记，无奈最后一篇迟迟不见更新，且看完标题之后，个人觉得前两篇内容足以涵盖“数据科学家养成”这一主题，故手指一抖，本笔记就诞生了。&lt;/p&gt;
&lt;p&gt;闲话少说，书归正传。这个主题为“How to Become a Data Scie
    
    </summary>
    
    
      <category term="数据科学" scheme="http://foxgem.github.io/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>作为TSDB的Elasticsearch</title>
    <link href="http://foxgem.github.io/2016/06/es-as-tsdb/"/>
    <id>http://foxgem.github.io/2016/06/es-as-tsdb/</id>
    <published>2016-06-30T08:06:28.000Z</published>
    <updated>2016-06-30T08:21:11.000Z</updated>
    
    <content type="html">&lt;p&gt;Elasticsearch可作为TSDB已经早有耳闻，而且自从v2版本之后，更是加了很多特性，使其更加适合作为TSDB使用。而&lt;a href=&quot;https://www.elastic.co/blog/elasticsearch-as-a-time-series-data-store&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这一篇文章&lt;/a&gt;给出了一个详细的例子，个人认为其最有价值的地方在于给出了一个参考的&lt;a href=&quot;https://github.com/stagemonitor/stagemonitor/blob/influxdb/stagemonitor-core/src/main/resources/stagemonitor-elasticsearch-metrics-index-template.json&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;schema mapping&lt;/a&gt;。尤其是其中将”_all”和”_source”设为关闭，余心有戚戚焉。&lt;/p&gt;
&lt;p&gt;同时，对于长期存储的优化建议也不错，但终究赶不上上面提到的mapping更直接，:)&lt;/p&gt;
&lt;p&gt;附带说一句，文中提到的&lt;a href=&quot;http://www.stagemonitor.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stagemonitor&lt;/a&gt;很让人惊艳，打算抽时间看看。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Elasticsearch可作为TSDB已经早有耳闻，而且自从v2版本之后，更是加了很多特性，使其更加适合作为TSDB使用。而&lt;a href=&quot;https://www.elastic.co/blog/elasticsearch-as-a-time-series-data-s
    
    </summary>
    
    
      <category term="数据库" scheme="http://foxgem.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>采用Seek Method加速分页</title>
    <link href="http://foxgem.github.io/2016/06/speed-up-pagination/"/>
    <id>http://foxgem.github.io/2016/06/speed-up-pagination/</id>
    <published>2016-06-13T11:41:15.000Z</published>
    <updated>2016-06-13T12:21:58.000Z</updated>
    
    <content type="html">&lt;p&gt;这是今天在&lt;a href=&quot;http://use-the-index-luke.com/no-offset&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;码天狗周刊上看到的文章&lt;/a&gt;，加上之前曾有过切身体会（只不过不是在SQL上），故觉得有必要摘记下来广而告之。&lt;/p&gt;
&lt;p&gt;凡事做过页面的，一般对分页不会陌生，也不会觉得它有多难：就是limit + offset的组合就可以了呀。但是，危险往往都是从最不起眼的地方开始的。在这里，我先说一下我之前在用MongoDB时遇到的问题。这类问题同样会出现在这种分页方式上。&lt;/p&gt;
&lt;p&gt;当时，我需要对于MongoDB中的数据进行处理，每次处理一批，也相当于是按页来操作数据啦。这个没啥难度，直接使用API中的find + skip + limit就可以轻易搞定。迅速把程序写完之后就开始拿产品库开搞了。刚开始一切正常，可过了没多久，就发现整个程序的性能下降了。进入Mongo一查，发现是Table Scan。哇，那个collection中有上千万的数据啊！&lt;/p&gt;
&lt;p&gt;此处略去3000字。&lt;/p&gt;
&lt;p&gt;总之，问题最后解决了，程序又运行如飞。而解决之道很简单：只用find + limit，不再使用skip（原因自己想）。只不过在find中加了一个条件：上一批的最后一个document的_id。整个代码形似（groovy代码）：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (docId) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    batch = collection.find([&amp;apos;_id&amp;apos;: [&amp;apos;$gt&amp;apos;: docId]] as Document).limit(BATCH_SIZE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    batch = collection.find().limit(BATCH_SIZE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docId = batch[-1][&amp;apos;_id&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它的原理很简单，其实就是利用可以利用的index来加速分页。这种思想跟今天看到的文章的思路如出一辙，不再使用offset，寻找能达到同样效果的index，用它来助力搜索。因此，文中给出的方案跟上面的代码类似：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SELECT ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  FROM ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; WHERE ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   AND id &amp;lt; ?last_seen_id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ORDER BY id DESC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; FETCH FIRST 10 ROWS ONLY&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种分页方式被称为“seek method”，其中的id被称为“seek predicate”。典型的seek predicate还可以是日期。需要提醒的是，seek predicate上需要有index才有意义，而且它可以有多列！采用这种方式的分页可以避免上述分页的潜在危险：当页数达到一定量之后，分页速度会严重下降。&lt;/p&gt;
&lt;p&gt;关于seek method，还可以参考下面的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.jooq.org/2013/10/26/faster-sql-paging-with-jooq-using-the-seek-method/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.jooq.org/2013/10/26/faster-sql-paging-with-jooq-using-the-seek-method/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://use-the-index-luke.com/sql/partial-results/fetch-next-page&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://use-the-index-luke.com/sql/partial-results/fetch-next-page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这是今天在&lt;a href=&quot;http://use-the-index-luke.com/no-offset&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;码天狗周刊上看到的文章&lt;/a&gt;，加上之前曾有过切身体会（只不过不是在SQL上），故觉得有必要摘记下来广
    
    </summary>
    
    
      <category term="数据库" scheme="http://foxgem.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="开发" scheme="http://foxgem.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>趣文三则</title>
    <link href="http://foxgem.github.io/2016/06/interesting-3/"/>
    <id>http://foxgem.github.io/2016/06/interesting-3/</id>
    <published>2016-06-12T11:06:01.000Z</published>
    <updated>2016-06-12T11:58:28.000Z</updated>
    
    <content type="html">&lt;p&gt;今天阅读了三篇有趣的短文，因为都不长而且易懂，所以就一起记下了。&lt;/p&gt;
&lt;h2 id=&quot;漫画：is-Java-Dying？&quot;&gt;&lt;a href=&quot;#漫画：is-Java-Dying？&quot; class=&quot;headerlink&quot; title=&quot;漫画：is Java Dying？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://dzone.com/articles/big-numbers-comic&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;漫画：is Java Dying？&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;知道天堂排名第三的人造数字是什么？咳咳，那就是“宣传Java正走向死亡的文章数量”，:)&lt;/p&gt;
&lt;h2 id=&quot;消灭if语句的方法总结&quot;&gt;&lt;a href=&quot;#消灭if语句的方法总结&quot; class=&quot;headerlink&quot; title=&quot;消灭if语句的方法总结&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://code.joejag.com/2016/anti-if-the-missing-patterns.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;消灭if语句的方法总结&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;if语句的问题已经是路人皆知了，文章介绍了5种方法来消灭它：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若方法的参数中有布尔类型，那就写成两个方法，一个对应false，另一个对应true&lt;/li&gt;
&lt;li&gt;用多态来替换switch语句&lt;/li&gt;
&lt;li&gt;采用Optional或NullObject避免null判断&lt;ul&gt;
&lt;li&gt;Optional在Java 8或Guava中都有&lt;/li&gt;
&lt;li&gt;NullObject，典型的如空数组或空字符串，视使用情况而定。Optional本质上也是一种NullObject。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尽量用inline语句来表达，如布尔表达式或三目运算符&lt;/li&gt;
&lt;li&gt;将反复出现的if语句往调用链的上游移动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人认为，可以从公共方法，且调用方最常用的那部分开始，逐步向内推进，这样可以让外层逻辑清爽很多。&lt;/p&gt;
&lt;h2 id=&quot;谎言的4种语言特征&quot;&gt;&lt;a href=&quot;#谎言的4种语言特征&quot; class=&quot;headerlink&quot; title=&quot;谎言的4种语言特征&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://lifehacker.com/learn-to-spot-a-liar-with-these-verbal-signs-1780047717&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;谎言的4种语言特征&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这篇文章相当于文中内嵌Ted视频的文字解读，列出了谎言的四种语言特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能少的自我引用，一般采用第三人称说话&lt;/li&gt;
&lt;li&gt;负面的语言，由于负罪感作祟&lt;/li&gt;
&lt;li&gt;简单阐述，因为大脑很难产生复杂的谎言&lt;/li&gt;
&lt;li&gt;故意用冗长晦涩的表达方式来讲一件简单的事情，简而言之就是“绕着弯说话”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天的阅读小结就到这里，谢谢！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天阅读了三篇有趣的短文，因为都不长而且易懂，所以就一起记下了。&lt;/p&gt;
&lt;h2 id=&quot;漫画：is-Java-Dying？&quot;&gt;&lt;a href=&quot;#漫画：is-Java-Dying？&quot; class=&quot;headerlink&quot; title=&quot;漫画：is Java Dying？&quot;
    
    </summary>
    
    
      <category term="阅读" scheme="http://foxgem.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>SMART帮助提高大脑的注意力和思考力</title>
    <link href="http://foxgem.github.io/2016/06/training-brain-to-focus/"/>
    <id>http://foxgem.github.io/2016/06/training-brain-to-focus/</id>
    <published>2016-06-11T10:40:35.000Z</published>
    <updated>2016-06-11T11:15:34.000Z</updated>
    
    <content type="html">&lt;p&gt;作为脑力工作者，有谁会嫌脑力提高太多呢？很自然的，当Pocket向我推荐&lt;a href=&quot;http://www.fastcompany.com/3060709/your-most-productive-self/how-to-train-your-brain-to-focus-remember-and-have-more-breakthrou&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇如何提高脑力的文章&lt;/a&gt;时，我毫不犹豫地打开了它。SMART，Strategic Memory Advanced Reasoning Training，就是文章中介绍的方法。这个号称9小时就能提升你大脑能力的培训包括3个关键内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Strategic Attention&lt;ul&gt;
&lt;li&gt;强调注意力，避免多任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Integration&lt;ul&gt;
&lt;li&gt;强调思考的深度和广度，既能抓住关键细节，同时又能将之放入到一个更大的框架之中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mental Flexibility&lt;ul&gt;
&lt;li&gt;强调思维角度的变换，而不仅仅只是从固有角度去看问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;似乎有点老调重弹是不是？相比起上面的内容，个人觉得SMART提出者给出的日常脑力改进建议要更有趣一些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停止多任务&lt;/li&gt;
&lt;li&gt;提炼加总结&lt;ul&gt;
&lt;li&gt;不断找出关键点，总结形成大局观；再从大局观，反查是否还有值得注意的细节。在“大局观”和“细节”之间不断切换，帮助加深对主题的理解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;尝试新视角&lt;/li&gt;
&lt;li&gt;让大脑放轻松&lt;ul&gt;
&lt;li&gt;紧张的大脑如同电量不足的电池，难以帮助手电发出强有力的光照亮我们前进的道路。放松的目的就是帮助大脑更好地积蓄电量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读少一点，读精一些&lt;ul&gt;
&lt;li&gt;这一点，个人持保留意见。我觉得只要自己掌握好就行了，区分哪些是精读，哪些是泛读就ok了。然后限定每天泛读的时间长度就好，而且泛读其实也相当于一种放松嘛。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有意思的是，SMART背后的组织还有今夏推出App（BrainHealth）的打算，到时候你会买吗？&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;作为脑力工作者，有谁会嫌脑力提高太多呢？很自然的，当Pocket向我推荐&lt;a href=&quot;http://www.fastcompany.com/3060709/your-most-productive-self/how-to-train-your-brain-to-focu
    
    </summary>
    
    
      <category term="阅读" scheme="http://foxgem.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>意识的进化史</title>
    <link href="http://foxgem.github.io/2016/06/theory-on-conscious-evolution/"/>
    <id>http://foxgem.github.io/2016/06/theory-on-conscious-evolution/</id>
    <published>2016-06-10T13:57:43.000Z</published>
    <updated>2016-06-10T14:30:49.000Z</updated>
    
    <content type="html">&lt;p&gt;意识是如何形成的？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.theatlantic.com/science/archive/2016/06/how-consciousness-evolved/485558/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇介绍神经学最新理论（The Attention Schema Theory）的科普文章&lt;/a&gt;在一开始就给出了答案：意识是大脑为处理复杂性而进化的结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The theory suggests that consciousness arises as a solution to one of the most fundamental problems facing any nervous system: Too much information constantly flows in to be fully processed. The brain evolved increasingly sophisticated mechanisms for deeply processing a few select signals at the expense of others, and in the AST, consciousness is the ultimate result of that evolutionary sequence.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在接下来的段落，文章回顾了大脑的进化过程，向我们展示了一个复杂神经系统的形成。让我这个外行基本看懂了，还是值得一读的，:)。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;意识是如何形成的？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.theatlantic.com/science/archive/2016/06/how-consciousness-evolved/485558/&quot; target=&quot;_blank&quot; rel=&quot;exte
    
    </summary>
    
    
      <category term="阅读" scheme="http://foxgem.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>为什么复杂的密码不能让你的账号更安全？</title>
    <link href="http://foxgem.github.io/2016/06/password-complexity/"/>
    <id>http://foxgem.github.io/2016/06/password-complexity/</id>
    <published>2016-06-09T12:36:07.000Z</published>
    <updated>2016-06-09T13:12:03.000Z</updated>
    
    <content type="html">&lt;p&gt;标题让人有些沮丧是不是？虽然我们一厢情愿地觉得复杂的密码可以保护我们，可一次又一次的网站脱裤事件却无情地把我们带回了现实。花2000美刀买来的机器就能在可接受的时间范围内搞定所有8字符的主流加密，&lt;a href=&quot;http://lifehacker.com/why-complex-password-requirements-dont-necessarily-make-1781311693&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章及其内链视频&lt;/a&gt;给出的数据足以让开发者警觉。&lt;/p&gt;
&lt;p&gt;更长、更复杂的密码似乎可以增加破解的难度和时间，然而常见的密码设定模式又为密码破解者充当了带路人。“You are not a unique snow flake!”，在视频结尾处演讲者这样说到。你想出的那些帮助你记住那些你自认为又长、又复杂和又安全密码的小伎俩已被千千万万个跟你同样的人使用，它们不仅帮助你记住了密码，也帮助了骇客破解密码。所以，文章写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The only secure password is the one you can’t remember.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这颇有点东方哲学的意味。面对凶险的安全环境，文章给出了四点建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个密码一个网站，记得起前阵子沸沸扬扬的小扎密码被盗事件吗？他的Twitter、Facebook和Pinterest密码完全一样！&lt;/li&gt;
&lt;li&gt;使用密码管理器，它会产生让你也记不住的密码&lt;/li&gt;
&lt;li&gt;在必需用密码的地方使用&lt;a href=&quot;http://www.searchsecurity.com.cn/whatis/word_3497.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;密码短语（passphrase）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;尽可能使用双因素认证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，大家有兴趣地可以用下面的两个链接来测试一下自己密码的安全性，看看花多长时间才能破解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://howsecureismypassword.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://howsecureismypassword.net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://password.kaspersky.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://password.kaspersky.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;标题让人有些沮丧是不是？虽然我们一厢情愿地觉得复杂的密码可以保护我们，可一次又一次的网站脱裤事件却无情地把我们带回了现实。花2000美刀买来的机器就能在可接受的时间范围内搞定所有8字符的主流加密，&lt;a href=&quot;http://lifehacker.com/why-comp
    
    </summary>
    
    
      <category term="安全" scheme="http://foxgem.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>拒绝“无条件的爱自己”</title>
    <link href="http://foxgem.github.io/2016/06/not-loving-yourself-just-as-you-are/"/>
    <id>http://foxgem.github.io/2016/06/not-loving-yourself-just-as-you-are/</id>
    <published>2016-06-08T11:04:54.000Z</published>
    <updated>2016-06-08T14:09:27.000Z</updated>
    
    <content type="html">&lt;p&gt;“我们采用的是敏捷，所以没有文档”，类似这样的话是不是有点耳熟？人就是这样的动物，同样一句话，总是倾向于从对自己有利的方面去解释。对待软件开发实践的态度尚且如此，怎么能指望对于自身的改进能比它更好呢？&lt;/p&gt;
&lt;p&gt;接纳不完美的自己，在鸡汤文满天飞的今天，类似的话不绝于耳。既然不完美，干脆就这样吧……然而，&lt;a href=&quot;http://qz.com/699741/a-harvard-philosophers-argument-for-not-loving-yourself-just-as-you-are/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这位哈佛的哲学家却不这样认为&lt;/a&gt;。他不仅不认同这样的观点，而且还认为中国先秦思想可以帮助我们获得更好的生活。有趣，在我们自己不断批判老祖宗的时候，一位老外说起了它的好话。&lt;/p&gt;
&lt;p&gt;这位哲学家认为，爱自己并且成为那个理想的真我的前提是得有那么一个“自我”存在。而在他看来，这未必正确。他援引中国思想家对于“自我”的观点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;much of the Chinese philosophical tradition derived from Confucius envisions “the self” as more of a messy product of habit than a clearly-defined inner essence. “From a very young age, we’ll form patterns of responding to the world. Those patterns will harden and become what we mistakenly call a personality,” adds Puett.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这两种观点有什么区别？在我看来，前者有一个可见的终点，而后者则有一种无限的可能。既是习惯的产物，那隐含的意思就是有机会改变，而改变的多寡只取决于你自己。于是，我们才有机会读到“吾日三省吾身”、“老骥伏枥志在千里”、“朝闻道夕死可矣”等等这样颇为励志的警句。&lt;/p&gt;
&lt;p&gt;有趣的是，心理学最近的一些发现为两千多年前老祖宗的观点提供了证据：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Though much of this writing is more than two thousand years old, recent findings in psychology have supported the notion that we are indeed creatures of habit. Puett points to Daniel Kahneman’s work, ‘Thinking, Fast and Slow,” which focuses in part on the persistent power of cognitive shortcuts, as an example of modern psychology that fits with ancient Chinese thinking.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无独有偶，古希腊哲学家亚里士多德也曾说：卓越的人之所以卓越，是因为有卓越的习惯！说得好，那就让我们先从习惯做起！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;“我们采用的是敏捷，所以没有文档”，类似这样的话是不是有点耳熟？人就是这样的动物，同样一句话，总是倾向于从对自己有利的方面去解释。对待软件开发实践的态度尚且如此，怎么能指望对于自身的改进能比它更好呢？&lt;/p&gt;
&lt;p&gt;接纳不完美的自己，在鸡汤文满天飞的今天，类似的话不绝于耳。
    
    </summary>
    
    
      <category term="阅读" scheme="http://foxgem.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>勤能补拙</title>
    <link href="http://foxgem.github.io/2016/06/practice-makes-possible/"/>
    <id>http://foxgem.github.io/2016/06/practice-makes-possible/</id>
    <published>2016-06-07T14:32:55.000Z</published>
    <updated>2016-06-07T15:19:04.000Z</updated>
    
    <content type="html">&lt;p&gt;这是&lt;a href=&quot;http://www.npr.org/sections/ed/2016/06/01/479335421/practice-makes-possible-what-we-learn-by-studying-amazing-kids&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇发表于NPR的一篇访谈&lt;/a&gt;，对象是“Peak: Secrets From The New Science Of Expertise”一书的作者。作者花费了大量的时间研究发现：大量有针对性的实践是天才成功的秘密。同时，他也不主张过多的强调天赋：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;he argues that “talent” is often a story we tell ourselves to justify our own failure or to protect children from the possibility of failure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在作者看来，实践是成功必要的保证，这一点与“眨眼之间”中提到的1万小时定律不谋而合。但若简单地把作者的观点归纳为：勤能补拙，未免有点太草率。其中有些细节之处值得注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实践固然重要，但必需是要有针对性的、能帮助你成长的实践，否则就是在同一个级别不断重复而已。还记得那些号称入行5、6年，但看代码和做事，充其量只值2、3年的人吗？&lt;/li&gt;
&lt;li&gt;好老师能够放大实践的效果。这一点在无数武侠小说中已经得到论证，在主人公练就绝世武功，迎娶白富美，走向人生巅峰的过程中，哪一个少得了世外高人的指导？&lt;/li&gt;
&lt;li&gt;成功的实践必然是那些能获得自我满足的实践，这样才有足够的驱动力让实践者坚持下去，否则，吉凶难测……&lt;/li&gt;
&lt;li&gt;尽可能地将学到的知识应用到自己的生活之中，这样才能真正有动力去学习，学习的效果也更好。作者举得一个例子就是通过看历史小说学历史，而不是通过死记硬背。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不出意料，这种文章放出来就引来了大批的评论，也顺便给网站带来了大量的流量。评论的焦点主要表现为读者对于作者忽略“天赋”的作用而表示愤慨，当然也有站在作者一方的。&lt;/p&gt;
&lt;p&gt;其实，我也承认天赋的重要性，否则的话，很难解释为何有的人就能轻而易举地解开你一辈子也解不开的难题。确实有些人就是为这而生的。然而，承认天才的存在并不是为了贬低实践的重要性。最起码，你只有做了，才知道自己是不是适合做这个，是不是在这行有天赋吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;http://www.npr.org/sections/ed/2016/06/01/479335421/practice-makes-possible-what-we-learn-by-studying-amazing-kids&quot; target=&quot;_b
    
    </summary>
    
    
      <category term="阅读" scheme="http://foxgem.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Groovy老鸟的回顾</title>
    <link href="http://foxgem.github.io/2016/06/groovy-a-retrospective/"/>
    <id>http://foxgem.github.io/2016/06/groovy-a-retrospective/</id>
    <published>2016-06-06T12:05:48.000Z</published>
    <updated>2016-06-06T12:18:11.000Z</updated>
    
    <content type="html">&lt;p&gt;今天在DZone上读到&lt;a href=&quot;https://dzone.com/articles/groovy-a-retrospective&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一名Groovy老鸟在即将转战其他语言之前写的自己对于Groovy的回顾总结&lt;/a&gt;。文章盛赞了Groovy的稳定和简洁，同时也提及了Java程序员转Groovy时需要注意的思维转变。余心有戚戚焉。&lt;/p&gt;
&lt;p&gt;关于类型这部分，我不能同意得更多：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Again, in my opinion, typing is better - I still don’t buy that typing def rather than the actual type is actually that much of a saving, and often ends up being a code-smell (even if it didn’t start out as one). The official Groovy recommendation is to type things, with the exception of local method scoped variables - but even in that case I cannot see the benefit: there is no real gain to the developer in typing those precious fewer characters and the future readability suffers as other developers have to track through the code more to be sure as to what a variable is doing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我记得在Burt寄给我的&lt;a href=&quot;https://www.amazon.cn/Programming-Grails-Beckwith-Burt/dp/1449323936/ref=sr_1_1?ie=UTF8&amp;amp;qid=1465215356&amp;amp;sr=8-1&amp;amp;keywords=Programming+grails&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;“Programming Grails”&lt;/a&gt;一书中也提到了类似关于在变量声明时是否明确声明变量类型的内容。我个人觉得宗旨就是：不要影响阅读性。而且，在使用@CompileStatic时，声明类型有助于减少修改编译错误的麻烦。此外，声明类型可以带来额外的好处：在像Idea这样的IDE中可以方便的查看对应类型的源代码（按住Ctrl，在相应类型上鼠标点击即可）。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在DZone上读到&lt;a href=&quot;https://dzone.com/articles/groovy-a-retrospective&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一名Groovy老鸟在即将转战其他语言之前写的自己对于Groovy的回
    
    </summary>
    
    
      <category term="开发" scheme="http://foxgem.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>数据仓库和BI的敏捷之道</title>
    <link href="http://foxgem.github.io/2016/06/agile-dw-bi/"/>
    <id>http://foxgem.github.io/2016/06/agile-dw-bi/</id>
    <published>2016-06-05T09:54:13.000Z</published>
    <updated>2016-06-05T10:24:18.000Z</updated>
    
    <content type="html">&lt;p&gt;相比十年前，如今敏捷已是路人皆知。然而，就数据仓库和BI项目来说，却鲜有相关文章涉及。今天&lt;a href=&quot;https://www.thoughtworks.com/insights/blog/agile-data-warehousing-and-business-intelligence-action&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;从Twitter看到的这篇发布在TW网站上的文章&lt;/a&gt;恰好可以补充我这方面的知识盲点。&lt;/p&gt;
&lt;p&gt;下面是我觉得一些有趣的地方（那份仿“敏捷宣言”的“DW/BI系统开发宣言”就算了，:)）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;难度和频率象限，重点关注那些处于“更频繁、难度更高”的用户故事&lt;/li&gt;
&lt;li&gt;项目的推荐目录结构，方便将相关产出纳入版本控制&lt;/li&gt;
&lt;li&gt;通过用户故事推动维度模型的演变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总得来讲，这篇文章是一份简要的数据仓库和BI项目敏捷实施指南。对于新手可以快速建立起全局观，对于老手则能带来一些新思路，读读还是不错的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;相比十年前，如今敏捷已是路人皆知。然而，就数据仓库和BI项目来说，却鲜有相关文章涉及。今天&lt;a href=&quot;https://www.thoughtworks.com/insights/blog/agile-data-warehousing-and-business-inte
    
    </summary>
    
    
      <category term="数据库" scheme="http://foxgem.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>拒绝低价值的工作</title>
    <link href="http://foxgem.github.io/2016/06/no-low-value-work/"/>
    <id>http://foxgem.github.io/2016/06/no-low-value-work/</id>
    <published>2016-06-04T11:42:09.000Z</published>
    <updated>2016-06-04T12:54:35.000Z</updated>
    
    <content type="html">&lt;p&gt;如何来衡量工作的“价值”从而方便判断它的高低？我的理解是：影响深远的工作就是有价值的，反之则是无价值或是价值低的。比如，手动部署，就是低价值的；而部署自动化，则是价值高的。因为很明显可以看出后者对开发的影响：把工程师从那些费事费力且容易出错的工作中解放出来，以从事更符合他们&lt;strong&gt;身份&lt;/strong&gt;的工作，:)。显然，从效益上讲，我们应该尽可能的做有价值的工作。&lt;/p&gt;
&lt;p&gt;无独有偶，&lt;a href=&quot;https://hbr.org/2016/06/stop-doing-low-value-work&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇哈佛商业评论上的文章以“停止做低价值的工作”为题讨论了如何提高生产力&lt;/a&gt;。其中的有些观点有点意思：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于经济下滑，工作职位虽然减少了，但工作量却没有。这导致每人的工作量都上升了，于是尽量避免低价值的工作对于职业生涯至关重要。&lt;/li&gt;
&lt;li&gt;当遇到组织重组时，人们会下意识的迎合他人，因为担心被解雇。但其实这是多余的，因为幸存下来的人对组织未来的成功至关重要。&lt;/li&gt;
&lt;li&gt;当完成了众人叫好的工作，乘机要求公司帮忙减少自己低价值的工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于如何避免继续做低价值的工作，除了IT人都知道的自动化大法，本文还给出了其他有益的建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把选择权交给他人来决定价值的高低&lt;/li&gt;
&lt;li&gt;将自己的做事规则公开&lt;/li&gt;
&lt;li&gt;每周自我总结&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，我还想补充一些关于自动化方面的内容。一说起自动化，想当然的会误解只有自己手头重复的工作才值得自动化。但还有一类容易被忽视就是自助类工具。比如，开发人员总会遇到有人找你来看看是不是你负责的那部分代码有问题。若能将整个运行日志（如果有的话）以合适的方式，如ELK，收集和展示出来，相信找你的人会少很多。这种自助类工具带来的效果往往比起仅仅服务于个人的自动化工具更好，因为它节约的是整个组织的多个人的时间。&lt;/p&gt;
&lt;p&gt;最后，作为结尾，我还想说：低价值的工作总得有人做，而且它本身对于人来讲也是相对的。一份工作，对于新人来说，可能是有价值的；但是对于老鸟，则可能不然。单纯地做低价值的工作是低价值的，但在不损伤结果的前提之下，消灭低价值工作，则是有价值的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如何来衡量工作的“价值”从而方便判断它的高低？我的理解是：影响深远的工作就是有价值的，反之则是无价值或是价值低的。比如，手动部署，就是低价值的；而部署自动化，则是价值高的。因为很明显可以看出后者对开发的影响：把工程师从那些费事费力且容易出错的工作中解放出来，以从事更符合他们
    
    </summary>
    
    
      <category term="阅读" scheme="http://foxgem.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>微服务的若干注意事项</title>
    <link href="http://foxgem.github.io/2016/06/microservice-pitfall/"/>
    <id>http://foxgem.github.io/2016/06/microservice-pitfall/</id>
    <published>2016-06-03T13:13:20.000Z</published>
    <updated>2016-06-03T13:21:58.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://dzone.com/articles/walking-the-microservices-path-towards-loose-coupl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;列出了若干微服务开发中的注意事项，涉及：共享数据库、安全、服务组合和依赖，给出参考链接也很赞，值得参考，特记之。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://dzone.com/articles/walking-the-microservices-path-towards-loose-coupl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;列出了若干微服务开发
    
    </summary>
    
    
      <category term="微服务" scheme="http://foxgem.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Groovy历史回顾</title>
    <link href="http://foxgem.github.io/2016/06/a-groovy-journey/"/>
    <id>http://foxgem.github.io/2016/06/a-groovy-journey/</id>
    <published>2016-06-02T13:25:08.000Z</published>
    <updated>2016-06-02T13:58:42.000Z</updated>
    
    <content type="html">&lt;p&gt;今天，Groovy的项目领导者Guillaume Laforge放出了&lt;a href=&quot;https://speakerdeck.com/glaforge/a-groovy-journey-in-open-source-land&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一篇名为“开源世界的Groovy之旅”的幻灯片&lt;/a&gt;，此片堪称“Groovy大事记”，记录了Groovy诞生至今的所有大事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Groovy诞生&lt;/li&gt;
&lt;li&gt;领导层变更&lt;/li&gt;
&lt;li&gt;各类重量级Groovy系开源软件的诞生：Grails、Gradle、Spock……&lt;/li&gt;
&lt;li&gt;Pivotal -&amp;gt; Apache&lt;/li&gt;
&lt;li&gt;各版本的特性&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一部至今为止最全的Groovy发展史，其中有不少戏剧性的转折，若对Groovy有兴趣，它是非常不错的补充学习材料。同时，关于Groovy，有一段引文被广为流传：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I can honestly say if someone had shown me the Programming in Scala book by by Martin Odersky, Lex Spoon &amp;amp; Bill Venners back in 2003 I’d probably have never created Groovy. - The creator of Groovy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它一直被Scala社区的哥们拿来刷优越感。可事实是，这位Creator严格的说并不是目前Groovy的Creator，他在Groovy 1.0之前很早就离开Groovy项目了。各位可以用自己的大脑来判定这句话的公正性。同时，从&lt;a href=&quot;http://stackoverflow.com/questions/1314732/scala-vs-groovy-vs-clojure&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇StackOverflow的回答&lt;/a&gt;可以看出，这哥们后来也离开了Scala社区，转而给Kotlin贡献代码。&lt;/p&gt;
&lt;p&gt;更具讽刺意味的是：Groovy这几年的TIOBE排名一直在上升，Jenkins 2.0、ElasticSearch、Vert.x等一系列重量级开源软件都支持Groovy。这有理由让人相信Groovy会有一个很好的未来。&lt;/p&gt;
&lt;p&gt;【免责说明：我没有兴趣拿一门语言打压另一个，这只是个人喜好而已。但我同意每年都学习一些新语言，变换一下自己的思维方式。若新语言可以简化工作，那是再好不过了。】&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天，Groovy的项目领导者Guillaume Laforge放出了&lt;a href=&quot;https://speakerdeck.com/glaforge/a-groovy-journey-in-open-source-land&quot; target=&quot;_blank&quot; rel=&quot;e
    
    </summary>
    
    
      <category term="开发" scheme="http://foxgem.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
